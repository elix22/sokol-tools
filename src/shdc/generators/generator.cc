/*
    Generator base class implementation.
*/
#include "generator.h"
#include "pystring.h"

using namespace shdc::refl;

namespace shdc::gen {

ErrMsg Generator::generate(const GenInput& gen) {
    ErrMsg err;
    err = begin(gen);
    if (err.valid()) {
        return err;
    }
    gen_prolog(gen);
    gen_header(gen);
    gen_prerequisites(gen);
    gen_vertex_attr_consts(gen);
    gen_bind_slot_consts(gen);
    gen_uniform_block_decls(gen);
    gen_storage_buffer_decls(gen);
    gen_stb_impl_start(gen);
    gen_shader_arrays(gen);
    gen_shader_desc_funcs(gen);
    if (gen.args.reflection) {
        gen_reflection_funcs(gen);
    }
    gen_epilog(gen);
    gen_stb_impl_end(gen);
    err = end(gen);
    return err;
}

Generator::ShaderStageArrayInfo Generator::shader_stage_array_info(const GenInput& gen, const ProgramReflection& prog, ShaderStage::Enum stage, Slang::Enum slang) {
    ShaderStageArrayInfo info;
    info.stage = prog.stages[stage].stage;
    if (info.stage == ShaderStage::Invalid) {
        return info;
    }
    const BytecodeBlob* bytecode_blob = gen.bytecode[slang].find_blob_by_snippet_index(prog.stage(stage).snippet_index);
    if (bytecode_blob) {
        info.has_bytecode = true;
        info.bytecode_array_size = bytecode_blob->data.size();
    }
    info.bytecode_array_name = shader_bytecode_array_name(prog.stage(stage).snippet_name, slang);
    info.source_array_name = shader_source_array_name(prog.stage(stage).snippet_name, slang);
    return info;
}

// default behaviour of begin is to clear the generated content string, and check for error in GenInput
ErrMsg Generator::begin(const GenInput& gen) {
    content.clear();
    return check_errors(gen);
}

// for anything written at the top of the file
void Generator::gen_prolog(const GenInput& gen) {
    // empty
}

// for anything written at the end of the file
void Generator::gen_epilog(const GenInput& gen) {
    // emptu
}

// create a default comment header
void Generator::gen_header(const GenInput& gen) {
    cbl_start();
    cbl("#version:{}# (machine generated, don't edit!)\n", gen.args.gen_version);
    cbl("\n");
    cbl("Generated by sokol-shdc (https://github.com/floooh/sokol-tools)\n");
    cbl("\n");
    if (!gen.args.no_log_cmdline) {
        cbl_open("Cmdline:\n");
        cbl("{}\n", gen.args.cmdline);
        cbl_close("\n");
    }

    cbl("Overview:\n");
    cbl("=========\n");
    for (const ProgramReflection& prog: gen.refl.progs) {
        cbl_open("Shader program: '{}':\n", prog.name);
        cbl("Get shader desc: {}", get_shader_desc_help(prog.name));
        gen_program_info(gen, prog);
        cbl_close();
    }
    cbl_open("Bindings:\n");
    gen_bindings_info(gen);
    cbl_close();
    cbl_end();
}

// written after the comment header
void Generator::gen_prerequisites(const GenInput& gen) {
    // empty
}

void Generator::gen_program_info(const GenInput& gen, const ProgramReflection& prog) {
    if (prog.has_vs()) {
        cbl("Vertex Shader: {}\n", prog.vs_name());
    }
    if (prog.has_fs()) {
        cbl("Fragment Shader: {}\n", prog.fs_name());
    }
    if (prog.has_cs()) {
        cbl("Compute Shader: {}\n", prog.cs_name());
    }
    if (prog.has_vs()) {
        cbl_open("Attributes:\n");
        for (const StageAttr& attr: prog.vs().inputs) {
            if (attr.slot >= 0) {
                cbl("{} => {}\n", vertex_attr_name(prog.name, attr), attr.slot);
            }
        }
        cbl_close();
    }
}

void Generator::gen_bindings_info(const GenInput& gen) {
    for (const UniformBlock& ub: gen.refl.bindings.uniform_blocks) {
        cbl_open("Uniform block '{}':\n", ub.name);
        cbl("{} struct: {}\n", lang_name(), struct_name(ub.name));
        cbl("Bind slot: {} => {}\n", uniform_block_bind_slot_name(ub), ub.sokol_slot);
        cbl_close();
    }
    for (const StorageBuffer& sbuf: gen.refl.bindings.storage_buffers) {
        cbl_open("Storage buffer '{}':\n", sbuf.name);
        cbl("{} struct: {}\n", lang_name(), struct_name(sbuf.struct_info.struct_items[0].struct_typename));
        cbl("Bind slot: {} => {}\n", storage_buffer_bind_slot_name(sbuf), sbuf.sokol_slot);
        cbl("Readonly: {}\n", sbuf.readonly);
        cbl_close();
    }
    for (const StorageImage& simg: gen.refl.bindings.storage_images) {
        cbl_open("Storage image '{}':\n", simg.name);
        cbl("Bind slot: {} => {}\n", storage_image_bind_slot_name(simg), simg.sokol_slot);
        cbl("Image type: {}\n", image_type(simg.type));
        cbl("Access format: {}\n", storage_pixel_format(simg.access_format));
        cbl("Writeonly: {}\n", simg.writeonly);
        cbl_close();
    }
    for (const Texture& tex: gen.refl.bindings.textures) {
        cbl_open("Texture '{}':\n", tex.name);
        cbl("Image type: {}\n", image_type(tex.type));
        cbl("Sample type: {}\n", image_sample_type(tex.sample_type));
        cbl("Multisampled: {}\n", tex.multisampled);
        cbl("Bind slot: {} => {}\n", texture_bind_slot_name(tex), tex.sokol_slot);
        cbl_close();
    }
    for (const Sampler& smp: gen.refl.bindings.samplers) {
        cbl_open("Sampler '{}':\n", smp.name);
        cbl("Type: {}\n", sampler_type(smp.type));
        cbl("Bind slot: {} => {}\n", sampler_bind_slot_name(smp), smp.sokol_slot);
        cbl_close();
    }
}

void Generator::gen_vertex_attr_consts(const GenInput& gen) {
    for (const ProgramReflection& prog: gen.refl.progs) {
        if (prog.has_vs()) {
            for (const StageAttr& attr: prog.vs().inputs) {
                if (attr.slot >= 0) {
                    l("{}\n", vertex_attr_definition(prog.name, attr));
                }
            }
        }
    }
}

void Generator::gen_bind_slot_consts(const GenInput& gen) {
    for (const UniformBlock& ub: gen.refl.bindings.uniform_blocks) {
        l("{}\n", uniform_block_bind_slot_definition(ub));
    }
    for (const StorageBuffer& sbuf: gen.refl.bindings.storage_buffers) {
        l("{}\n", storage_buffer_bind_slot_definition(sbuf));
    }
    for (const StorageImage& simg: gen.refl.bindings.storage_images) {
        l("{}\n", storage_image_bind_slot_definition(simg));
    }
    for (const Texture& tex: gen.refl.bindings.textures) {
        l("{}\n", texture_bind_slot_definition(tex));
    }
    for (const Sampler& smp: gen.refl.bindings.samplers) {
        l("{}\n", sampler_bind_slot_definition(smp));
    }
}

void Generator::gen_uniform_block_decls(const GenInput& gen) {
    for (const UniformBlock& ub: gen.refl.bindings.uniform_blocks) {
        gen_uniform_block_decl(gen, ub);
    }
}

void Generator::gen_storage_buffer_decls(const GenInput& gen) {
    for (const Type& sbuf_struct: gen.refl.sbuf_structs) {
        gen_storage_buffer_decl(gen, sbuf_struct);
    }
}

void Generator::gen_shader_arrays(const GenInput& gen) {
    for (int slang_idx = 0; slang_idx < Slang::Num; slang_idx++) {
        Slang::Enum slang = Slang::from_index(slang_idx);
        if (gen.args.slang & Slang::bit(slang)) {
            const Spirvcross& spirvcross = gen.spirvcross[slang];
            const Bytecode& bytecode = gen.bytecode[slang];
            for (int snippet_index = 0; snippet_index < (int)gen.inp.snippets.size(); snippet_index++) {
                const Snippet& snippet = gen.inp.snippets[snippet_index];
                if ((snippet.type != Snippet::VS) && (snippet.type != Snippet::FS) && (snippet.type != Snippet::CS)) {
                    continue;
                }
                const SpirvcrossSource* src = spirvcross.find_source_by_snippet_index(snippet_index);
                assert(src);
                const BytecodeBlob* blob = bytecode.find_blob_by_snippet_index(snippet_index);
                std::vector<std::string> lines;
                pystring::splitlines(src->source_code, lines);
                // first write the source code in a comment block
                cbl_start();
                for (const std::string& line: lines) {
                    cbl("{}\n", replace_C_comment_tokens(line));
                }
                cbl_end();
                if (blob) {
                    const std::string array_name = shader_bytecode_array_name(snippet.name, slang);
                    gen_shader_array_start(gen, array_name, blob->data.size(), slang);
                    const size_t len = blob->data.size();
                    for (size_t i = 0; i < len; i++) {
                        if ((i & 15) == 0) {
                            l("    ");
                        }
                        l("{:#04x},", blob->data[i]);
                        if ((i & 15) == 15) {
                            l("\n");
                        }
                    }
                    gen_shader_array_end(gen);
                } else {
                    // if no bytecode exists, write the source code, but also a byte array with a trailing 0
                    const std::string array_name = shader_source_array_name(snippet.name, slang);
                    const size_t len = src->source_code.length() + 1;
                    gen_shader_array_start(gen, array_name, len, slang);
                    for (size_t i = 0; i < len; i++) {
                        if ((i & 15) == 0) {
                            l("    ");
                        }
                        l("{:#04x},", (int)src->source_code[i]);
                        if ((i & 15) == 15) {
                            l("\n");
                        }
                    }
                    gen_shader_array_end(gen);
                }
            }
        }
    }
}

void Generator::gen_shader_desc_funcs(const GenInput& gen) {
    for (const auto& prog: gen.refl.progs) {
        gen_shader_desc_func(gen, prog);
    }
}

void Generator::gen_reflection_funcs(const GenInput& gen) {
    for (const auto& prog: gen.refl.progs) {
        gen_attr_slot_refl_func(gen, prog);
        gen_texture_slot_refl_func(gen, prog);
        gen_sampler_slot_refl_func(gen, prog);
        gen_uniform_block_slot_refl_func(gen, prog);
        gen_uniform_block_size_refl_func(gen, prog);
        gen_uniform_offset_refl_func(gen, prog);
        gen_uniform_desc_refl_func(gen, prog);
        gen_storage_buffer_slot_refl_func(gen, prog);
        gen_storage_image_slot_refl_func(gen, prog);
    }
}

// default behaviour of end() is to write the output file
ErrMsg Generator::end(const GenInput& gen) {
    FILE* f = fopen(gen.args.output.c_str(), "w");
    if (!f) {
        return ErrMsg::error(gen.inp.base_path, 0, fmt::format("failed to open output file '{}'", gen.args.output));
    }
    fwrite(content.c_str(), content.length(), 1, f);
    fclose(f);
    return ErrMsg();
}

// check that each input shader has the expected stage shaders
ErrMsg Generator::check_errors(const GenInput& gen) {
    for (int i = 0; i < Slang::Num; i++) {
        Slang::Enum slang = Slang::from_index(i);
        if (gen.args.slang & Slang::bit(slang)) {
            for (const auto& item: gen.inp.programs) {
                const Program& prog = item.second;
                if (prog.has_vs_fs()) {
                    int vs_snippet_index = gen.inp.snippet_map.at(prog.vs_name);
                    int fs_snippet_index = gen.inp.snippet_map.at(prog.fs_name);
                    const SpirvcrossSource* vs_src = gen.spirvcross[i].find_source_by_snippet_index(vs_snippet_index);
                    const SpirvcrossSource* fs_src = gen.spirvcross[i].find_source_by_snippet_index(fs_snippet_index);
                    if (vs_src == nullptr) {
                        return gen.inp.error(gen.inp.snippets[vs_snippet_index].lines[0],
                            fmt::format("no generated '{}' source for vertex shader '{}' in program '{}'",
                            Slang::to_str(slang), prog.vs_name, prog.name));
                    }
                    if (fs_src == nullptr) {
                        return gen.inp.error(gen.inp.snippets[vs_snippet_index].lines[0],
                            fmt::format("no generated '{}' source for fragment shader '{}' in program '{}'",
                            Slang::to_str(slang), prog.fs_name, prog.name));
                    }
                } else {
                    int cs_snippet_index = gen.inp.snippet_map.at(prog.cs_name);
                    const SpirvcrossSource* cs_src = gen.spirvcross[i].find_source_by_snippet_index(cs_snippet_index);
                    if (cs_src == nullptr) {
                        return gen.inp.error(gen.inp.snippets[cs_snippet_index].lines[0],
                            fmt::format("no generated '{}' source for compute shader '{}' in program '{}'",
                            Slang::to_str(slang), prog.vs_name, prog.name));
                    }
                }
            }
        }
    }
    // all ok
    return ErrMsg();
}

int Generator::roundup(int val, int round_to) {
    return (val + (round_to - 1)) & ~(round_to - 1);
}

std::string Generator::replace_C_comment_tokens(const std::string& str) {
    static const std::string comment_start_old = "/*";
    static const std::string comment_start_new = "/_";
    static const std::string comment_end_old = "*/";
    static const std::string comment_end_new = "_/";
    std::string s = pystring::replace(str, comment_start_old, comment_start_new);
    s = pystring::replace(s, comment_end_old, comment_end_new);
    return s;
}
std::string Generator::to_pascal_case(const std::string& str) {
    std::vector<std::string> splits;
    pystring::split(str, splits, "_");
    std::vector<std::string> parts;
    for (const auto& part: splits) {
        parts.push_back(pystring::capitalize(part));
    }
    return pystring::join("", parts);
}

std::string Generator::to_ada_case(const std::string& str) {
    std::vector<std::string> splits;
    pystring::split(str, splits, "_");
    std::vector<std::string> parts;
    for (const auto& part: splits) {
        parts.push_back(pystring::capitalize(part));
    }
    return pystring::join("_", parts);
}

std::string Generator::to_camel_case(const std::string& str) {
    std::string res = to_pascal_case(str);
    res[0] = tolower(res[0]);
    return res;
}

const char* Generator::hlsl_target(Slang::Enum slang, ShaderStage::Enum stage) {
    switch (slang) {
        case Slang::HLSL4: switch (stage) {
            case ShaderStage::Vertex: return "vs_4_0";
            case ShaderStage::Fragment: return "ps_4_0";
            case ShaderStage::Compute: return "cs_4_0";
            default: return nullptr;
        }
        case Slang::HLSL5: switch (stage) {
            case ShaderStage::Vertex: return "vs_5_0";
            case ShaderStage::Fragment: return "ps_5_0";
            case ShaderStage::Compute: return "cs_5_0";
            default: return nullptr;
        }
        default: return 0;
    }
}

} // namespace
